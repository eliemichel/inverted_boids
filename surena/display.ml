(*
	Display affiche une simulation, potentiellement personnalisable en donnant
	des arguments.
*)

open Graphics
open Engine

let dump_file = ref ""

let _ = Random.init (int_of_float (100. *. Unix.time ()))

let draw_boid boid =
	let x,y = boid.pos in
		set_color boid.color;
		fill_circle (truncate x) (truncate y) 3

let n = 200

let uniform n a = Array.init n (fun _ -> Array.make n a)

let quadblock n a b c d =
	Array.init n (fun i -> Array.init n (fun j ->
		if i < n/2
		then
			if j < n/2
			then a
			else b
		else
			if j < n/2
			then c
			else d
	))
	(** Array.make_matrix... *)
(* let rules = [
	Array.make n 0.01, Cohesion (uniform n 1., uniform n 0.5, uniform n 100.);
	Array.make n 15., Repulsion (uniform n 1., uniform n 2., uniform n 20.);
	Array.make n 1., Alignment (uniform n 1., uniform n 0.5, uniform n 100.);
] *)
(* TODO : Procédures pratiques de construction de règle *)

let rules cm ca cl rm ra rl am aa al im sm =
(*	let cb = Array.make n cb in *)
	let cm = uniform n cm in
	let ca = uniform n ca in
	let cl = uniform n cl in
(*	let rb = Array.make n rb in *)
	let rm = uniform n rm in
	let ra = uniform n ra in
	let rl = uniform n rl in
(*	let ab = Array.make n ab in *)
	let am = uniform n am in
	let aa = uniform n aa in
	let al = uniform n al in
	let im = Array.make n im in
	let sm = Array.make n sm in
	let rules = [
		Cohesion (cm,ca,cl);
		Repulsion (rm,ra,rl);
		Alignment (am,aa,al);
		Inertia im;
		Stay sm
	] in
	rules,(cm,ca,cl),(rm,ra,rl),(am,aa,al),im,sm


let rules =
	let rules,(cm,_,_),(rm,ra,rl),_,_,_ = rules
		0.001 0.5 100.
		10. 0.5 20.
		0.005 0.5 100.
		0.9
		10. in
(*	let rules,(cb,_,_,_),(_,rm,ra,rl),_,_ = rules
		0.0073 1. 0.5 100.
		5.002 1. 0.5 20.
		0.73849 1. 0.5 100.
		0.363 in
*)
(*	cb.(0) <- 0.1;
	for i = 1 to n - 1 do
		rl.(i).(0) <- 100.;
		ra.(i).(0) <- 1.;
		rm.(i).(0) <- 10.
	done; *)
	rules


(* 
let rules =
	let cb = Array.make n 0.01 in
	let cm = quadblock n 1. 0. 0. 1. in
	let ca = quadblock n 0.5 0. 0. 0.5 in
	let cl = quadblock n 100. 0. 0. 100. in
	let rb = Array.make n 10. in
	let rm = quadblock n 1. 0. 0. 1. in
	let ra = quadblock n 2. 0. 0. 2. in
	let rl = quadblock n 20. 0. 0. 20. in
	let ab = Array.make n 0.5 in
	let am = quadblock n 1. 0. 0. 1. in
	let aa = quadblock n 0.5 0. 0. 0.5 in
	let al = quadblock n 100. 0. 0. 100. in
	let ib = Array.make n 0.5 in
	let rules = [
		cb, Cohesion (cm,ca,cl);
		rb, Repulsion (rm,ra,rl);
		ab, Alignment (am,aa,al);
		ib, Inertia
	] in
	cb.(0) <- 0.1;
	for i = 1 to n - 1 do
		rl.(i).(0) <- 100.;
		ra.(i).(0) <- 1.;
		rm.(i).(0) <- 10.
	done;
	rules
*)

let nb_cycles = ref (-1)

let boids = Array.init n (fun i -> default_boid ())

let () =
	boids.(0) <- { boids.(0) with color = Graphics.black };
	for k = 1 to n/2 - 1 do
		boids.(k) <- { boids.(k) with color = Graphics.blue }
	done

let main () =
	let oc =
		if !dump_file = "" then stdout
		else open_out_bin !dump_file in
	if !dump_file = "" then (
		let s = " " ^ (string_of_int Engine.capxi) ^ "x"
			^ (string_of_int Engine.capyi) in
		open_graph s;
		set_window_title "Boids";
		auto_synchronize false
	) else (
		output_value oc !nb_cycles;
		output_value oc n
	);
	let i = ref 0 in
	while !dump_file = "" && not (key_pressed () && read_key () = 'q')
		|| !nb_cycles > 0 && !i < !nb_cycles do
		if !dump_file = "" then (
			clear_graph ();
			Array.iter draw_boid boids;
			synchronize ();
			ignore (Unix.system "sleep 0.02")
		) else Array.iter (output_value oc) boids;
		Engine.step boids rules;
		incr i
	done;
	if !dump_file = "" then 
		close_graph ()
	else
		close_out oc;
	exit(0)


let () = Arg.parse
	["--dump", Arg.Set_string dump_file,
	 "dump the data generated by the simulation in the given file.";
	 "-n", Arg.Set_int nb_cycles,
	 "number of cycles to run"]
	(fun _ -> ())
	"Usage : display.\n\
	Display a multi-agent boids-based simulation.\n\
	The available options are :"
	;
	main ()





