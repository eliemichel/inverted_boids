(*
	Display affiche une simulation, potentiellement personnalisable en donnant
	des arguments.
*)

open Graphics
open Engine

let dump_file = ref ""

let _ = Random.init (int_of_float (100. *. Unix.time ()))

let draw_boid boid =
	let x,y = boid.pos in
		set_color boid.color;
		fill_circle (truncate x) (truncate y) 3

let n = 200

let uniform n a = Array.init n (fun _ -> Array.make n a)

let quadblock n a b c d =
	Array.init n (fun i -> Array.init n (fun j ->
		if i < n/2
		then
			if j < n/2
			then a
			else b
		else
			if j < n/2
			then c
			else d
	))
	(** Array.make_matrix... *)
(* let rules = [
	Array.make n 0.01, Cohesion (uniform n 1., uniform n 0.5, uniform n 100.);
	Array.make n 15., Repulsion (uniform n 1., uniform n 2., uniform n 20.);
	Array.make n 1., Alignment (uniform n 1., uniform n 0.5, uniform n 100.);
] *)
(* TODO : Procédures pratiques de construction de règle *)

let rules cb cm ca cl rb rm ra rl ab am aa al ib =
	let cb = Array.make n cb in
	let cm = uniform n cm in
	let ca = uniform n ca in
	let cl = uniform n cl in
	let rb = Array.make n rb in
	let rm = uniform n rm in
	let ra = uniform n ra in
	let rl = uniform n rl in
	let ab = Array.make n ab in
	let am = uniform n am in
	let aa = uniform n aa in
	let al = uniform n al in
	let ib = Array.make n ib in
	let rules = [
		cb, Cohesion (cm,ca,cl);
		rb, Repulsion (rm,ra,rl);
		ab, Alignment (am,aa,al);
		ib, Inertia
	] in
	rules,(cb,cm,ca,cl),(rb,rm,ra,rl),(ab,am,aa,al),ib


let rules =
	let rules,(cb,_,_,_),(_,rm,ra,rl),_,_ = rules
		0.01 1. 0.5 100.
		10. 1. 2. 20.
		0.5 1. 0.5 100.
		0.5 in
	cb.(0) <- 0.1;
	for i = 1 to n - 1 do
		rl.(i).(0) <- 100.;
		ra.(i).(0) <- 1.;
		rm.(i).(0) <- 10.
	done;
	rules



let rules =
	let cb = Array.make n 0.01 in
	let cm = quadblock n 1. 0. 0. 1. in
	let ca = quadblock n 0.5 0. 0. 0.5 in
	let cl = quadblock n 100. 0. 0. 100. in
	let rb = Array.make n 10. in
	let rm = quadblock n 1. 0. 0. 1. in
	let ra = quadblock n 2. 0. 0. 2. in
	let rl = quadblock n 20. 0. 0. 20. in
	let ab = Array.make n 0.5 in
	let am = quadblock n 1. 0. 0. 1. in
	let aa = quadblock n 0.5 0. 0. 0.5 in
	let al = quadblock n 100. 0. 0. 100. in
	let ib = Array.make n 0.5 in
	let rules = [
		cb, Cohesion (cm,ca,cl);
		rb, Repulsion (rm,ra,rl);
		ab, Alignment (am,aa,al);
		ib, Inertia
	] in
	cb.(0) <- 0.1;
	for i = 1 to n - 1 do
		rl.(i).(0) <- 100.;
		ra.(i).(0) <- 1.;
		rm.(i).(0) <- 10.
	done;
	rules




let boids = Array.init n (fun i -> default_boid ())

let () =
	boids.(0) <- { boids.(0) with color = Graphics.black };
	for k = 1 to n/2 - 1 do
		boids.(k) <- { boids.(k) with color = Graphics.blue }
	done

let main arg =
	open_graph " 600x600";
	set_window_title "Boids";
	auto_synchronize false;
	while not (key_pressed () && read_key () = 'q') do
		clear_graph ();
		Array.iter draw_boid boids;
		Engine.step boids rules;
		synchronize ();
		ignore (Unix.system "sleep 0.02");
	done;
	close_graph ();
	exit(0)


let () = Arg.parse
	["--dump", Arg.Set_string dump_file,
	 "dump the data generated by the simulation in the given file."]
	main
	"Usage : display.\n\
	Display a multi-agent boids-based simulation.\n\
	The available options are :"
	;
	main ()





